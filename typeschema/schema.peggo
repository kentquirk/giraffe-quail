// This is a parser file for parsing graphql's type definition schema.
// It is designed to be consumed by pigeon.
// (see https://godoc.org/github.com/PuerkitoBio/pigeon)
//
// A couple of notes if you're thinking of contributing:
// The intent is to keep this file as minimal as possible and
// to put as much supporting code into .go files as can be reasonably
// managed.
//
// Format-wise, we're using a style that works pretty well for YACC grammars.
// Namely, we enclose choice expressions in () and then align these, plus the different
// options for a choice expression (which are separated by /) all to the same column.
// The code blocks are indented further than these elements.
// One-line definitions can be placed on one line.

{
    package typeschema

    var TR *TypeRegistry
    var VR *ValueRegistry
}

// Documents
Document <-
    ( Definition+ _ EOF
    )

Definition <-
    ( ObjTypeDefinition
    / EnumDefinition
    / InterfaceDefinition
    / UnionDefinition
    )

ObjTypeDefinition <- _ "type" _ Name Implements? FieldSet

EnumDefinition <- _ "enum" _ n:Name vals:EnumValueSet {
        enumname := n.(string)
        enumtype, err := TR.Register(enumname, Enum)
        if err != nil {
            return enumtype, err
        }
        for _, v := range vals.([]string) {
            enumvalue := v
            _, err := VR.Register(enumvalue, Value{T:enumtype, V:enumvalue})
            if err != nil {
                return enumtype, err
            }
        }
        return enumtype, nil
    }


InterfaceDefinition <- _ "interface" _ n:Name fs:FieldSet {
        fields := make([]Field, 0)
        for _, f := range fs.([]Field) {
            fields = append(fields, f)
        }
        return TR.RegisterFields(n.(string), Interface, fields)
    }

UnionDefinition <- _ "union" _ Name UnionSet

// Implements can only have the name of an Object Type
Implements <- _ "implements" _ Name

EnumValueSet <- _ "{" ev:EnumValues _ "}" { return ev, nil }

EnumValues <- evs:EnumValue+ {
    r := make([]string, 0)
    for _, n := range evs.([]interface{}) {
        r = append(r, n.(string))
    }
    return r, nil
}

EnumValue <- _ n:Name { return n.(string), nil }

UnionSet <- _ "=" UnionNames

UnionNames <- _ Name (_ "|" _ Name)*

FieldSet <-  _ "{" fields:Field+ _ "}" {
        fa := make([]Field, 0)
        for _, f := range fields.([]interface{}) {
            fa = append(fa, f.(Field))
        }
        return fa, nil
    }

Field <- _ n:Name args:Arguments? _ ":" t:Type {
        if args == nil {
            return Field{N: n.(string), T:t.(Type)}, nil
        }
        return Field{N: n.(string), Args:args.([]Field), T:t.(Type)}, nil
    }

Arguments <- _ '(' args:Argument+ _ ')' {
        fields := make([]Field, 0)
        for _, a := range args.([]interface{}) {
            fields = append(fields, a.(Field))
        }
        return fields, nil
    }

Argument <- _ n:Name _ ':' t:Type {
        name := n.(string)
        typ := t.(Type)
        return Field{N: name, T: typ}, nil
    }


Type <-
    ( NonNullType
    / ListType
    / NamedType
    )

NamedType <- _ n:Name { return TR.MaybeGet(n.(string)) }

ListType <- _ '[' _ t:Type _ ']' { return TR.MaybeGet(TypeNameFor(List, t.(Type).Key())) }

NonNullType <-
    ( t:ListType '!'  { return TR.MaybeGet(TypeNameFor(NonNullable, t.(Type).Key())) }
    / t:NamedType '!' { return TR.MaybeGet(TypeNameFor(NonNullable, t.(Type).Key())) }
    )


// Ignored Tokens
_ <- I*
I "Ignored" <-
   ( UnicodeBOM
   / WhiteSpace
   / LineTerminator
   / Comment
   / Comma
   )

// Here are the character classes

UnicodeBOM "ByteOrderMark" <-
    '\uFEFF'

LineTerminator "EOL" <-
    ( '\n'
    / '\r' !'\n'
    / '\r' '\n'
    )

WhiteSpace <- [ \t]
Comment <- '#' .* !LineTerminator
Comma <- ','
Name <- [_A-Za-z][_0-9A-Za-z]* { return string(c.text), nil }

EOF = !.