// This is a parser file for parsing graphql.
// It is designed to be consumed by pigeon.
// (see https://godoc.org/github.com/PuerkitoBio/pigeon)
//
// A couple of notes if you're thinking of contributing:
// The intent is to keep this file as minimal as possible and
// to put as much supporting code into .go files as can be reasonably
// managed.
//
// Format-wise, we're using a style that works pretty well for YACC grammars.
// Namely, we enclose choice expressions in () and then align these, plus the different
// options for a choice expression (which are separated by /) all to the same column.
// The code blocks are indented further than these elements.
// One-line definitions can be placed on one line.

{
    package parser

    import "github.com/kentquirk/giraffe-quail/types"

    var TR *types.TypeRegistry
    var VR *types.ValueRegistry
}

// Documents
Document <-
    ( Definition+ _ EOF
    )

Definition <-
    ( FragmentDefinition
    / OperationDefinition
    )

OperationDefinition <-
    ( OperationType _ Name? VariableDefinitions? Directives? SelectionSet
    / SelectionSet
    )

OperationType <-
    ( _ "query"
    / _ "mutation"
    / _ n:Name { return n, c.NewError("Must be query or mutation.", "OT-1") }
    )

SelectionSet <- _ '{' Selection+ _ '}'

Selection <-
    ( Field
    / FragmentSpread
    / InlineFragment
    )

Field <- Alias? _ Name Arguments? Directives? SelectionSet?

Arguments <- _ '(' Argument+ _ ')'

Argument <- _ Name _ ':' _ Value

Alias <- _ Name _ ':'

FragmentSpread <- _ "..." FragmentName Directives?

FragmentDefinition <- _ "fragment" FragmentName TypeCondition Directives? SelectionSet

FragmentName <- _ Name    // but not 'on'

TypeCondition <- _ "on" _ NamedType

InlineFragment <- _ "..." TypeCondition? Directives? SelectionSet

// Values
Value <-
    ( Variable
    / FloatValue
    / IntValue
    / StringValue
    / BooleanValue
    / NullValue
    / EnumValue    // but not true, false, or null, so must be after bool and null
    / ListValue
    / ObjectValue
    )

IntValue <- IntegerPart { return typereg.ParseInt(string(c.text)) }
IntegerPart <-
    ( NegativeSign? '0'
    / NegativeSign? NonZeroDigit Digit*
    )

FloatValue <-
    ( IntegerPart FractionalPart
    / IntegerPart ExponentPart
    / IntegerPart FractionalPart ExponentPart
    ) { return typereg.ParseFloat(string(c.text)) }
FractionalPart <- '.' Digit+
ExponentPart <- ExponentIndicator Sign? Digit+

BooleanValue <-
    ( _ "true" { return typereg.MakeBool(true), nil }
    / _ "false" { return typereg.MakeBool(false), nil }
    )

StringValue <-
    ( _ '"' '"' { return typereg.MakeStr(""), nil }
    / _ '"' s:StringChars '"' { return typereg.MakeStr(s.(string)), nil }
    / _ '"' s:StringChars !'"' {
        return typereg.MakeStr(s.(string)), c.NewError("Missing close quote for string.", "SV-1")
        }
    )

StringChars <- StringCharacter+ { return string(c.text), nil }

StringCharacter <-
    // 'SourceCharacter but not " or \ or LineTerminator'
    ( [\u0009\u0020\u0021\u0023-\u005B\u005D-\uFFFF]
    / '\\' 'u' EscapedUnicode
    / '\\' EscapedCharacter
    ) { return c.text, nil }

NullValue <- _ "null" { return typereg.MakeNull(), nil }

EnumValue <- Name
    { return typereg.FindEnum(string(c.text)) }

ListValue <-
    ( _ '[' _ ']' { return typereg.MakeList(), nil }
    / _ '[' va:(_ Value)+ ']' {
            values := va.([]interface{})
            list := typereg.MakeListOf(values[0].(Value).T);
            for _, v := range values {
                list.Append(v.(Value))
            }
            return list, nil
        }
    / _ '[' (_ Value)+ !']' {
            return typereg.MakeList(), c.NewError("Missing close square bracket for list.", "LV-1")
        }
    )

ObjectValue <-
    ( _ '{' _ '}' { return typereg.MakeNamelessObj(), nil }
    / _ '{' oa:ObjectField+ _ '}' {
            obj := typereg.MakeNamelessObj()
            fields := oa.([]interface{})
            for _, v := range fields  {
                // the ObjectField is a Value where the N field is the name
                // of the field, and the V field is a nested Value object
                obj.SetField(v.(Value))
            }
            return obj, nil
        }
    / _ '{' oa:ObjectField+ _ !'}' {
            return typereg.MakeNamelessObj(), c.NewError("Missing close curly brace for object.", "OV-1")
        }
    )

ObjectField <- _ n:Name _ ':' _ v:Value { return Value{N:n.(string), V:v}, nil }


// Variables
Variable <- _ '$' Name { return Variable{N:string(c.text)}, nil }

VariableDefinitions <- _ '(' _ VariableDefinition+ _ ')'

VariableDefinition <- _ vi:Variable _ ':' _ ti:Type dvi:DefaultValue?
    {
        v := vi.(Variable)
        t := ti.(Type)
        dv := dvi.(Value)
        v.T = t
        v.V = dv
        return v, nil
    }

DefaultValue <- _ '=' _ Value

// Types
Type <-
    ( NonNullType
    / ListType
    / NamedType
    )

NamedType <- n:Name { return typereg.Get(n.(string)) }

ListType <- _ '[' _ t:Type _ ']' { return ListType{Contains:t.(Type)}, nil }

NonNullType <-
    ( t:NamedType '!' { return NonNullType{Contains:t.(Type)}, nil }
    / t:ListType '!' { return NonNullType{Contains:t.(Type)}, nil }
    )

// Directives
Directives <- Directive+

Directive <- _ '@' Name _ Arguments?


// Lexical Tokens:
Token <-
    ( Punctuator
    / Name
    / IntValue
    / FloatValue
    / StringValue
    )

// Ignored Tokens
_ <- I*
I "Ignored" <-
   ( UnicodeBOM
   / WhiteSpace
   / LineTerminator
   / Comment
   / Comma
   )

// Here are the character classes

SourceCharacter <-
    [\u0009\n\u000D\u0020-\uFFFF]

UnicodeBOM "ByteOrderMark" <-
    '\uFEFF'

LineTerminator "EOL" <-
    ( '\n'
    / '\r' !'\n'
    / '\r' '\n'
    )

WhiteSpace <- [ \t]
Comment <- '#' .* !LineTerminator
Comma <- ','
NegativeSign <- '-'
Digit <- [0-9]
NonZeroDigit <- [1-9]
ExponentIndicator <- [eE]
Sign <- [+-]
EscapedUnicode <- [0-9A-Fa-f]//{4}
EscapedCharacter <- ["\\/bfnrt]

Punctuator <-
    ( [!$():=@[\]{|}]
    / "..."
    )

Name <- [_A-Za-z][_0-9A-Za-z]* { return string(c.text), nil }

EOF = !.