// This is a parser file for parsing graphql.
// It is designed to be consumed by pigeon.
// (see https://godoc.org/github.com/PuerkitoBio/pigeon)
//
// A couple of notes if you're thinking of contributing:
// The intent is to keep this file as minimal as possible and
// to put as much supporting code into .go files as can be reasonably
// managed.
//
// Format-wise, we're using a style that works pretty well for YACC grammars.
// Namely, we enclose choice expressions in () and then align these, plus the different
// options for a choice expression (which are separated by /) all to the same column.
// The code blocks are indented further than these elements.
// One-line definitions can be placed on one line.

{
    package parser
}

// Documents
Document <-
    ( Definition+ _ EOF
    )

Definition <-
    ( FragmentDefinition
    / OperationDefinition
    )

OperationDefinition <-
    ( OperationType _ Name? VariableDefinitions? Directives? SelectionSet
    / SelectionSet
    )

OperationType <-
    ( _ "query"
    / _ "mutation"
    / _ n:Name { return n, c.NewError("Must be query or mutation.", "OT-1") }
    )

SelectionSet <- _ '{' Selection+ _ '}'

Selection <-
    ( Field
    / FragmentSpread
    / InlineFragment
    )

Field <- Alias? _ Name Arguments? Directives? SelectionSet?

Arguments <- _ '(' Argument+ _ ')'

Argument <- _ Name _ ':' _ Value

Alias <- _ Name _ ':'

FragmentSpread <- _ "..." FragmentName Directives?

FragmentDefinition <- _ "fragment" FragmentName TypeCondition Directives? SelectionSet

FragmentName <- _ Name    // but not 'on'

TypeCondition <- _ "on" _ NamedType

InlineFragment <- _ "..." TypeCondition? Directives? SelectionSet

// Values
Value <-
    ( Variable
    / IntValue
    / FloatValue
    / StringValue
    / BooleanValue
    / NullValue
    / EnumValue
    / ListValue
    / ObjectValue
    )

IntValue <- IntegerPart { return ParseInt(string(c.text)) }
IntegerPart <-
    ( NegativeSign? '0'
    / NegativeSign? NonZeroDigit Digit*
    )

FloatValue <-
    ( IntegerPart FractionalPart
    / IntegerPart ExponentPart
    / IntegerPart FractionalPart ExponentPart
    ) { return ParseFloat(string(c.text)) }
FractionalPart <- '.' Digit+
ExponentPart <- ExponentIndicator Sign? Digit+

BooleanValue <-
    ( _ "true" { return MakeBool(true), nil }
    / _ "false" { return MakeBool(false), nil }
    )

StringValue <-
    ( _ '"' '"' { return MakeStr(""), nil }
    / _ '"' s:StringChars '"' { return MakeStr(s.(string)), nil }
    / _ '"' s:StringChars !'"' {
        return MakeStr(s.(string)), c.NewError("Missing close quote for string.", "SV-1")
        }
    )

StringChars <- StringCharacter+ { return string(c.text), nil }

StringCharacter <-
    // 'SourceCharacter but not " or \ or LineTerminator'
    ( [\u0009\u0020\u0021\u0023-\u005B\u005D-\uFFFF]
    / '\\' 'u' EscapedUnicode
    / '\\' EscapedCharacter
    ) { return c.text, nil }

NullValue <- _ "null" { return MakeNull(), nil }

EnumValue <- Name   // but not true, false, or null
    { return MakeEnum(string(c.text)), nil }

ListValue <-
    ( _ '[' _ ']' { return MakeList(), nil }
    / _ '[' va:(_ Value)+ ']' {
            list := MakeList();
            for _, v := range va.([]interface{}) {
                list.Append(v.(Value))
            }
            return list, nil
        }
    / _ '[' (_ Value)+ !']' {
            return MakeList(), c.NewError("Missing close square bracket for list.", "LV-1")
        }
    )

ObjectValue <-
    ( _ '{' _ '}' { return MakeObj(), nil }
    / _ '{' oa:ObjectField+ _ '}' {
            obj := MakeObj()
            for _, v := range oa.([]interface{}) {
                obj.SetField(v.(Value))
            }
            return obj, nil
        }
    / _ '{' oa:ObjectField+ _ !'}' {
            return "invalid object", c.NewError("Missing close curly brace for object.", "OV-1")
        }
    )

ObjectField <- _ n:Name _ ':' _ v:Value { return MakeField(n.(string), v.(Value)), nil }


// Variables
Variable <- _ '$' Name { return MakeVar(string(c.text)), nil }

VariableDefinitions <- _ '(' _ VariableDefinition+ _ ')'

VariableDefinition <- _ vi:Variable _ ':' _ t:Type dv:DefaultValue?

DefaultValue <- _ '=' _ Value

// Types
Type <-
    ( NonNullType
    / ListType
    / NamedType
    )

NamedType <- Name

ListType <- _ '[' _ Type _ ']'

NonNullType <-
    ( NamedType '!'
    / ListType '!'
    )

// Directives
Directives <- Directive+

Directive <- _ '@' Name _ Arguments?


// Lexical Tokens:
Token <-
    ( Punctuator
    / Name
    / IntValue
    / FloatValue
    / StringValue
    )

// Ignored Tokens
_ <- I*
I "Ignored" <-
   ( UnicodeBOM
   / WhiteSpace
   / LineTerminator
   / Comment
   / Comma
   )

// Here are the character classes

SourceCharacter <-
    [\u0009\n\u000D\u0020-\uFFFF]

UnicodeBOM "ByteOrderMark" <-
    '\uFEFF'

LineTerminator "EOL" <-
    ( '\n'
    / '\r' !'\n'
    / '\r' '\n'
    )

WhiteSpace <- [ \t]
Comment <- '#' .* !LineTerminator
Comma <- ','
NegativeSign <- '-'
Digit <- [0-9]
NonZeroDigit <- [1-9]
ExponentIndicator <- [eE]
Sign <- [+-]
EscapedUnicode <- [0-9A-Fa-f]//{4}
EscapedCharacter <- ["\\/bfnrt]

Punctuator <-
    ( [!$():=@[\]{|}]
    / "..."
    )

Name <- [_A-Za-z][_0-9A-Za-z]*

EOF = !.