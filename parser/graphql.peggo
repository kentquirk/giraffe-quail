// This is a parser file for parsing graphql.
// It is designed to be consumed by pigeon.
// (see https://godoc.org/github.com/PuerkitoBio/pigeon)
//
// A couple of notes if you're thinking of contributing:
// The intent is to keep this file as minimal as possible and
// to put as much supporting code into .go files as can be reasonably
// managed.
//
// Format-wise, we're using a style that works pretty well for YACC grammars.
// Namely, we enclose choice expressions in () and then align these, plus the different
// options for a choice expression (which are separated by /) all to the same column.
// The code blocks are indented further than these elements.
// One-line definitions can be placed on one line.

{
    package parser

    import "github.com/kentquirk/giraffe-quail/types"
}

// Documents
Document <-
    ( Definition+ _ EOF
    )

Definition <-
    ( FragmentDefinition
    / OperationDefinition
    )

OperationDefinition <-
    ( OperationType _ Name? VariableDefinitions? Directives? SelectionSet
    / SelectionSet
    )

OperationType <-
    ( _ "query"
    / _ "mutation"
    / _ n:Name { return n, c.NewError("Must be query or mutation.", "OT-1") }
    )

SelectionSet <- _ '{' Selection+ _ '}'

Selection <-
    ( Field
    / FragmentSpread
    / InlineFragment
    )

Field <- Alias? _ Name Arguments? Directives? SelectionSet?

Arguments <- _ '(' Argument+ _ ')'

Argument <- _ Name _ ':' _ Value

Alias <- _ Name _ ':'

FragmentSpread <- _ "..." FragmentName Directives?

FragmentDefinition <- _ "fragment" FragmentName TypeCondition Directives? SelectionSet

FragmentName <- _ Name    // but not 'on'

TypeCondition <- _ "on" _ NamedType

InlineFragment <- _ "..." TypeCondition? Directives? SelectionSet

// Values
Value <-
    ( Variable
    / FloatValue
    / IntValue
    / StringValue
    / BooleanValue
    / NullValue
    / EnumValue    // but not true, false, or null, so must be after bool and null
    / ListValue
    / ObjectValue
    )

IntValue <- IntegerPart { return TR.ParseInt(string(c.text)) }
IntegerPart <-
    ( NegativeSign? '0'
    / NegativeSign? NonZeroDigit Digit*
    )

FloatValue <-
    ( IntegerPart FractionalPart
    / IntegerPart ExponentPart
    / IntegerPart FractionalPart ExponentPart
    ) { return TR.ParseFloat(string(c.text)) }
FractionalPart <- '.' Digit+
ExponentPart <- ExponentIndicator Sign? Digit+

BooleanValue <-
    ( _ "true" { return TR.MakeBool(true), nil }
    / _ "false" { return TR.MakeBool(false), nil }
    )

StringValue <-
    ( _ '"' '"' { return TR.MakeStr(""), nil }
    / _ '"' s:StringChars '"' { return TR.MakeStr(s.(string)), nil }
    / _ '"' s:StringChars !'"' {
        return TR.MakeStr(s.(string)), c.NewError("Missing close quote for string.", "SV-1")
        }
    )

StringChars <- StringCharacter+ { return string(c.text), nil }

StringCharacter <-
    // 'SourceCharacter but not " or \ or LineTerminator'
    ( [\u0009\u0020\u0021\u0023-\u005B\u005D-\uFFFF]
    / '\\' 'u' EscapedUnicode
    / '\\' EscapedCharacter
    ) { return c.text, nil }

NullValue <- _ "null" { return TR.MakeNull(), nil }

EnumValue <- Name
    { return GlobalScope.Get(string(c.text)) }

ListValue <-
    ( _ '[' _ ']' { return TR.MakeEmptyList(), nil }
    / _ '[' va:(OneValue)+ ']' {
            values := va.([]interface{})
            list := TR.MakeListOf(values[0].(types.Value).T);
            for _, v := range values {
                err := list.Append(v.(types.Value))
                if err != nil {
                    return list, c.WrapError(err, "LV-1")
                }
            }
            return list, nil
        }
    / _ '[' (OneValue)+ !']' {
            return TR.MakeEmptyList(), c.NewError("Missing close square bracket for list.", "LV-2")
        }
    )

OneValue <- _ v:Value { return v, nil }

ObjectValue <-
    ( _ '{' _ '}' { return TR.MakeNamelessObj(), nil }
    / _ '{' oa:ObjectField+ _ '}' {
            obj := TR.MakeNamelessObj()
            fields := oa.([]interface{})
            for _, v := range fields  {
                f := v.(types.NamedValue)
                err := obj.SetField(f.N, f.V)
                if err != nil {
                    return obj, c.WrapError(err, "OV-1")
                }
            }
            return obj, nil
        }
    / _ '{' oa:ObjectField+ _ !'}' {
            return TR.MakeNamelessObj(), c.NewError("Missing close curly brace for object.", "OV-2")
        }
    )

ObjectField <- _ n:Name _ ':' _ v:Value {
        return types.NamedValue{N:n.(string), V:v.(types.Value)}, nil
    }


// Variable
Variable <- _ '$' n:Name { return "$"+n.(string), nil }

VariableDefinitions <- _ '(' _ VariableDefinition+ _ ')'

VariableDefinition <- _ n:Variable _ ':' _ ti:Type dvi:DefaultValue?
    {
        name := n.(string)
        t := ti.(types.Type)
        v, err := TR.MakeValueOf(t)
        if err != nil {
            return TR.MakeNull(), c.WrapError(err, "VD-1")
        }
        if dvi != nil {
            err := v.Set(dvi.(types.Value))
            if err != nil {
                return TR.MakeNull(), c.WrapError(err, "VD-2")
            }
        }
        return GlobalScope.Create(name, v)
    }

DefaultValue <- _ '=' _ Value

// Types
Type <-
    ( NonNullType
    / ListType
    / NamedType
    )

NamedType <- n:Name { return TR.Get(n.(string)) }

ListType <- _ '[' _ t:Type _ ']' {
        return TR.ListType(t.(types.Type)), nil
    }

NonNullType <-
    ( t:NamedType '!' {
            return TR.NonNullableType(t.(types.Type)), nil
        }
    / t:NonNullType '!' {
            return TR.NonNullableType(t.(types.Type)), nil
        }
    )

// Directives
Directives <- Directive+

Directive <- _ '@' Name _ Arguments?


// Lexical Tokens:
Token <-
    ( Punctuator
    / Name
    / IntValue
    / FloatValue
    / StringValue
    )

// Ignored Tokens
_ <- I*
I "Ignored" <-
   ( UnicodeBOM
   / WhiteSpace
   / LineTerminator
   / Comment
   / Comma
   )

// Here are the character classes

SourceCharacter <-
    [\u0009\n\u000D\u0020-\uFFFF]

UnicodeBOM "ByteOrderMark" <-
    '\uFEFF'

LineTerminator "EOL" <-
    ( '\n'
    / '\r' !'\n'
    / '\r' '\n'
    )

WhiteSpace <- [ \t]
Comment <- '#' .* !LineTerminator
Comma <- ','
NegativeSign <- '-'
Digit <- [0-9]
NonZeroDigit <- [1-9]
ExponentIndicator <- [eE]
Sign <- [+-]
EscapedUnicode <- [0-9A-Fa-f]//{4}
EscapedCharacter <- ["\\/bfnrt]

Punctuator <-
    ( [!$():=@[\]{|}]
    / "..."
    )

Name <- [_A-Za-z][_0-9A-Za-z]* { return string(c.text), nil }

EOF = !.